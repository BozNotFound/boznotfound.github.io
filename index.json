[{"content":"","date":"2024 年 9 月 3 日","permalink":"/","section":"(･∀･)ﾉﾞ嗨，在这里","summary":"","title":"(･∀･)ﾉﾞ嗨，在这里"},{"content":"114\n","date":"2024 年 9 月 3 日","permalink":"/post/leetcode_delete-and-earn/","section":"Posts","summary":"114","title":"Leetcode——740.删除并获得点数"},{"content":"","date":"2024 年 9 月 3 日","permalink":"/post/","section":"Posts","summary":"","title":"Posts"},{"content":"\rLeetCode——70.爬楼梯 # 题目概述 # 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n示例 1：\n输入：n = 2\r输出：2\r解释：有两种方法可以爬到楼顶。\r1. 1 阶 + 1 阶\r2. 2 阶 示例 2：\n输入：n = 3\r输出：3\r解释：有三种方法可以爬到楼顶。\r1. 1 阶 + 1 阶 + 1 阶\r2. 1 阶 + 2 阶\r3. 2 阶 + 1 阶 提示：\n1 \u0026lt;= n \u0026lt;= 45 问题分析 # 递归：O(2^n) # 一开始首先想到的解决办法就是递归，因此自然想到了递归公式：\nclimbStairs(n)=climbStairs(n-1)+climbStairs(n-2); 写好了之后提交了一次，结果显示超时，测试用例是1 \u0026lt;= n \u0026lt;= 45，也不算很大的数据，那说明是递归的过程中存在了问题。\n来看一下第一次提交超时的代码：\nclass Solution { public: int climbStairs(int n) { if(n==1||n==2) return n; else{ return climbStairs(n-1)+climbStairs(n-2); } } }; 可以看到每一次递归都需要分别计算两个子问题，因此时间复杂度达到了O(2^n)，超时也就不奇怪了。\n动态规划：O(N) # 动态规划的递推式也是和递归类似：\ndp[i]=dp[i-1]+dp[i-2]; 这里用到了数组，我们首先定义数组dp[n+1]，初始状态下除了dp[0]=dp[1]=1，其他的元素值都为0。这样我们就可以通过for循环执行递推式来得到结果，最后返回dp[n]的值：\nclass Solution { public: int climbStairs(int n) { int dp[n+1]; for(int i=0;i\u0026lt;=n;i++){ dp[i]=0; } dp[0]=1,dp[1]=1; for(int i=2;i\u0026lt;=n;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; } }; 时间复杂度为O(N)，源于for循环(2-\u0026gt;n)。\n优化\u0026amp;改进 # 我们注意到，上面使用动态规划算法的空间复杂度是O(N)，可不可以进行优化呢？\n要优化空间复杂度，就需要从数组入手，我们假设在递推式中result=first+second，那么第二次循环执行的就是newResult=result+second，这时候first的空间就空闲了，这时如果我们把newResult存储到first的位置上，只需要三个变量就可以解决了，时间复杂度就变成了O(1)，循环部分就变成：\nfor(int i=0;i\u0026lt;=n;i++){ result=first+second; first=second; second=result; } 最后我们得到了空间复杂度为O(1)的代码：\nclass Solution { public: int climbStairs(int n) { int p = 0, q = 0, r = 1; for (int i = 1; i \u0026lt;= n; ++i) { p = q; q = r; r = p + q; } return r; } }; 补充 # 最后再补充两种做法，一种是矩阵快速幂，可以将时间复杂度降到O(logn)：\nclass Solution { public: vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; multiply(vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; \u0026amp;a, vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; \u0026amp;b) { vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; c(2, vector\u0026lt;long long\u0026gt;(2)); for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; } } return c; } vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; matrixPow(vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; a, int n) { vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; ret = {{1, 0}, {0, 1}}; while (n \u0026gt; 0) { if ((n \u0026amp; 1) == 1) { ret = multiply(ret, a); } n \u0026gt;\u0026gt;= 1; a = multiply(a, a); } return ret; } int climbStairs(int n) { vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; ret = {{1, 1}, {1, 0}}; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; res = matrixPow(ret, n); return res[0][0]; } }; 还有就是通过求解斐波那契数列的递推公式来直接计算：\n$$F(n) = \\frac{1}{\\sqrt{5}} \\left( \\left( \\frac{1 + \\sqrt{5}}{2} \\right)^n - \\left( \\frac{1 - \\sqrt{5}}{2} \\right)^n \\right)$$\nclass Solution { public: int climbStairs(int n) { double sqrt5 = sqrt(5); double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1); return (int)round(fibn / sqrt5); } }; 具体的复杂度和机器有关\n","date":"2024 年 4 月 8 日","permalink":"/post/leetcode_climbstairs/","section":"Posts","summary":"LeetCode——70.","title":"LeetCode——70.爬楼梯"},{"content":"\r提醒！ 这里是一些实验性短码，或许在未来可以派上用场\r1. 在Github上\r关注我\r","date":"2023 年 11 月 7 日","permalink":"/post/%E6%B5%8B%E8%AF%95/","section":"Posts","summary":"提醒！ 这里是一些实验性短码，或许在未来可以派上用场\r1.","title":"测试"},{"content":"","date":"0001 年 1 月 1 日","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001 年 1 月 1 日","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"0001 年 1 月 1 日","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"0001 年 1 月 1 日","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]