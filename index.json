[{"content":"","date":"2024 年 4 月 8 日","permalink":"/","section":"(･∀･)ﾉﾞ嗨，在这里","summary":"","title":"(･∀･)ﾉﾞ嗨，在这里"},{"content":"\rLeetCode——70.爬楼梯 # 题目概述 # 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n示例 1：\n输入：n = 2\r输出：2\r解释：有两种方法可以爬到楼顶。\r1. 1 阶 + 1 阶\r2. 2 阶 示例 2：\n输入：n = 3\r输出：3\r解释：有三种方法可以爬到楼顶。\r1. 1 阶 + 1 阶 + 1 阶\r2. 1 阶 + 2 阶\r3. 2 阶 + 1 阶 提示：\n1 \u0026lt;= n \u0026lt;= 45 问题分析 # 递归：O(2^n) # 一开始首先想到的解决办法就是递归，因此自然想到了递归公式：\nclimbStairs(n)=climbStairs(n-1)+climbStairs(n-2); 写好了之后提交了一次，结果显示超时，测试用例是1 \u0026lt;= n \u0026lt;= 45，也不算很大的数据，那说明是递归的过程中存在了问题。\n来看一下第一次提交超时的代码：\nclass Solution { public: int climbStairs(int n) { if(n==1||n==2) return n; else{ return climbStairs(n-1)+climbStairs(n-2); } } }; 可以看到每一次递归都需要分别计算两个子问题，因此时间复杂度达到了O(2^n)，超时也就不奇怪了。\n动态规划：O(N) # 动态规划的递推式也是和递归类似：\ndp[i]=dp[i-1]+dp[i-2]; 这里用到了数组，我们首先定义数组dp[n+1]，初始状态下除了dp[0]=dp[1]=1，其他的元素值都为0。这样我们就可以通过for循环执行递推式来得到结果，最后返回dp[n]的值：\nclass Solution { public: int climbStairs(int n) { int dp[n+1]; for(int i=0;i\u0026lt;=n;i++){ dp[i]=0; } dp[0]=1,dp[1]=1; for(int i=2;i\u0026lt;=n;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; } }; 时间复杂度为O(N)，源于for循环(2-\u0026gt;n)。\n优化\u0026amp;改进 # 我们注意到，上面使用动态规划算法的空间复杂度是O(N)，可不可以进行优化呢？\n要优化空间复杂度，就需要从数组入手，我们假设在递推式中result=first+second，那么第二次循环执行的就是newResult=result+second，这时候first的空间就空闲了，这时如果我们把newResult存储到first的位置上，只需要三个变量就可以解决了，时间复杂度就变成了O(1)，循环部分就变成：\nfor(int i=0;i\u0026lt;=n;i++){ result=first+second; first=second; second=result; } 最后我们得到了空间复杂度为O(1)的代码：\nclass Solution { public: int climbStairs(int n) { int p = 0, q = 0, r = 1; for (int i = 1; i \u0026lt;= n; ++i) { p = q; q = r; r = p + q; } return r; } }; 补充 # 最后再补充两种做法，一种是矩阵快速幂，可以将时间复杂度降到O(logn)：\nclass Solution { public: vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; multiply(vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; \u0026amp;a, vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; \u0026amp;b) { vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; c(2, vector\u0026lt;long long\u0026gt;(2)); for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; } } return c; } vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; matrixPow(vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; a, int n) { vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; ret = {{1, 0}, {0, 1}}; while (n \u0026gt; 0) { if ((n \u0026amp; 1) == 1) { ret = multiply(ret, a); } n \u0026gt;\u0026gt;= 1; a = multiply(a, a); } return ret; } int climbStairs(int n) { vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; ret = {{1, 1}, {1, 0}}; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; res = matrixPow(ret, n); return res[0][0]; } }; 还有就是通过求解斐波那契数列的递推公式来直接计算：\n$$F(n) = \\frac{1}{\\sqrt{5}} \\left( \\left( \\frac{1 + \\sqrt{5}}{2} \\right)^n - \\left( \\frac{1 - \\sqrt{5}}{2} \\right)^n \\right)$$\nclass Solution { public: int climbStairs(int n) { double sqrt5 = sqrt(5); double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1); return (int)round(fibn / sqrt5); } }; 具体的复杂度和机器有关\n","date":"2024 年 4 月 8 日","permalink":"/post/leetcode_climbstairs/","section":"Posts","summary":"LeetCode——70.","title":"LeetCode——70.爬楼梯"},{"content":"","date":"2024 年 4 月 8 日","permalink":"/post/","section":"Posts","summary":"","title":"Posts"},{"content":"\r提醒！ 这里是一些实验性的短码，或许在未来可以派上用场\r1. 在Github上\r关注我\r","date":"2023 年 11 月 7 日","permalink":"/post/%E6%B5%8B%E8%AF%95/","section":"Posts","summary":"提醒！ 这里是一些实验性的短码，或许在未来可以派上用场\r1.","title":"测试"},{"content":"\r写在前面 # 笔者对于Golang可以说是真正的零基础，不过好在之前学过C++,有些东西倒也是共通的，这篇以及之后的笔记就当作自己的一个记录，也可以算是和大家的一些分享 : )\n在这篇以及之后的文章中，我希望能够把所要讲的知识写得详细一些，这也并不是说把每个知识点都列出来；此外，在前期基础语法方面我也会写一些关于C++与Golang的区别，内容或许不会很精良，就权当是锻炼自己写文章的能力吧\n下面是一些可能会用到的工具：不要点击来路不明的链接\nGolang官方网站\r：链接 Golang圣经（《The Go Programming Language》)\r：中文地址 ：英文原版 Golang环境配置教程\r：golang环境详细安装、配置 Golang的优点 # 清晰并且简洁 # Go 努力保持小并且优美，你可以在短短几行代码里做许多事情 并行 # Go 让函数很容易成为非常轻量的线程。这些线程在 Go 中被叫做 goroutines 快速 # 编译很快，执行也很快。目标是跟 C 一样快。编译时间用秒计算 安全 # 当转换一个类型到另一个类型的时候需要显式的转换并遵循严格的规则。Go 有 垃圾收集，在 Go 中无须 free()，语言会处理这一切 UTF-8 # 任何地方都是 UTF-8 的，包括字符串以及程序代码 开心 # 用 Go 写程序会非常开心！（来源于《Learning Go》） 先从Hello World说起 # package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;hello,world\u0026#34;) } 输出结果将会是：\nhello,world Go build与Go run # 但是，我们希望将这一段程序编译，以备将来使用，这时候我们就需要使用go build指令来生成一个可执行的二进制文件（Windows下表现为一个.exe后缀文件），之后便可以在Windows命令行输入该文件名称来直接运行，换而言之，它可以随时运行而不需要担心系统库的更新。\n只需要直接运行编译好的.exe文件就可以得到我们想要的结果了\n还有一种方法，我们在命令行中直接对main.go执行go run操作，该命令可以直接 对main.go进行编译运行\n程序解析 # Go 语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个 .go 源代码文件组成，目录定义包的作用。每个源文件都以一条 package 声明语句开始，这个例子里就是 package main，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。\nGo 的标准库提供了 100 多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如 fmt 包，就含有格式化输出、接收输入的函数。Println 是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。\n跟随在 package 声明后面的 import 声明，其作用是告诉编译器源文件需要哪些包。这里举例的hello world 例子只用到了一个包，大多数程序需要导入多个包。\n在程序中必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入未使用的包（Go 语言编译过程没有警告信息）。\nGo 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响 Go 代码的正确解析。举个例子，函数的左括号 { 必须和 func 函数声明在同一行上，且位于末尾，不能独占一行。\n例如，下面的程序就无法通过编译：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;hello,world\u0026#34;) } 原因是左括号单独成行\n总结 # 和C++相比，Go相对来说更加简洁，在形式上与C++也有很多相似的地方，需要注意的是编译运行（go run/go build)、package的严格要求以及行末换行的问题\n下一篇预告：Golang程序结构\n","date":"2023 年 11 月 1 日","permalink":"/post/%E5%8F%B2/","section":"Posts","summary":"写在前面 # 笔者对于Golang可以说是真正的零基础，不过好在之前学过C++,有些东西倒也是共通的，这篇以及之后的笔记就当作自己的一个记录，也可以算是和大家的一些分享 : )","title":"Golang基础笔记(1)"},{"content":"","date":"0001 年 1 月 1 日","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001 年 1 月 1 日","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"0001 年 1 月 1 日","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"0001 年 1 月 1 日","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]